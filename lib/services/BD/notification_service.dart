import 'dart:developer' as developer;
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:kanjad/basicdata/notification.dart' as kanjad;

class NotificationService {
  late SupabaseClient supabase;

  NotificationService._internal() {
    supabase = Supabase.instance.client;
  }

  static final NotificationService _instance = NotificationService._internal();
  static NotificationService get instance => _instance;

  // Nom de la table
  final String tableNotifications = 'notifications';

  // Helper to insert notification
  Future<void> _insererNotification(kanjad.Notification notification) async {
    // The 'idnotification' is a UUID generated by the database, so we should not send it.
    // Let's create a map and remove the id if it's empty.
    final map = notification.toMap();
    if (notification.idnotification.isEmpty) {
      map.remove('idnotification');
    }
    await supabase.from(tableNotifications).insert(map);
  }

  // ==================== MÉTHODES DE CRÉATION DE NOTIFICATIONS ====================

  /// Créer une notification de connexion utilisateur
  Future<void> creerNotificationConnexion(String idutilisateur, String nomUtilisateur) async {
    try {
      final notification = kanjad.Notification(
        idnotification: '', // Sera généré par Supabase
        titre: 'Nouvelle connexion',
        message: '$nomUtilisateur s\'est connecté à l\'application',
        type: 'connexion',
        priorite: 'normale',
        statut: 'non_lu',
        idutilisateur: idutilisateur,
        datecreation: DateTime.now(),
      );

      await _insererNotification(notification);
      developer.log('Notification de connexion créée pour $nomUtilisateur', name: 'NotificationService');
    } catch (e, stackTrace) {
      developer.log('Erreur création notification connexion: $e', name: 'NotificationService', error: e, stackTrace: stackTrace);
      rethrow;
    }
  }

  /// Créer une notification de nouvelle commande
  Future<void> creerNotificationCommande(String idcommande, String idutilisateur) async {
    try {
      final notification = kanjad.Notification(
        idnotification: '',
        titre: 'Nouvelle commande',
        message: 'Une nouvelle commande a été créée',
        type: 'commande',
        priorite: 'haute',
        statut: 'non_lu',
        idutilisateur: idutilisateur,
        idcommande: idcommande,
        datecreation: DateTime.now(),
      );

      await _insererNotification(notification);
      developer.log('Notification de commande créée pour $idcommande', name: 'NotificationService');
    } catch (e, stackTrace) {
      developer.log('Erreur création notification commande: $e', name: 'NotificationService', error: e, stackTrace: stackTrace);
      rethrow;
    }
  }

  /// Créer une notification d'assignation de livraison
  Future<void> creerNotificationLivraison(String idcommande, String idlivreur) async {
    try {
      final notification = kanjad.Notification(
        idnotification: '',
        titre: 'Livraison assignée',
        message: 'Une nouvelle livraison vous a été assignée',
        type: 'livraison',
        priorite: 'haute',
        statut: 'non_lu',
        idutilisateur: idlivreur,
        idcommande: idcommande,
        datecreation: DateTime.now(),
      );

      await _insererNotification(notification);
      developer.log('Notification de livraison créée pour $idlivreur', name: 'NotificationService');
    } catch (e, stackTrace) {
      developer.log('Erreur création notification livraison: $e', name: 'NotificationService', error: e, stackTrace: stackTrace);
      rethrow;
    }
  }

  /// Créer une notification de paiement
  Future<void> creerNotificationPaiement(String idcommande, bool succes) async {
    try {
      final notification = kanjad.Notification(
        idnotification: '',
        titre: succes ? 'Paiement réussi' : 'Échec de paiement',
        message: succes
            ? 'Le paiement de la commande a été validé'
            : 'Le paiement de la commande a échoué',
        type: 'paiement',
        priorite: succes ? 'normale' : 'critique',
        statut: 'non_lu',
        idcommande: idcommande,
        datecreation: DateTime.now(),
      );

      await _insererNotification(notification);
      developer.log('Notification de paiement créée pour $idcommande (succès: $succes)', name: 'NotificationService');
    } catch (e, stackTrace) {
      developer.log('Erreur création notification paiement: $e', name: 'NotificationService', error: e, stackTrace: stackTrace);
      rethrow;
    }
  }

  /// Créer une notification d'alerte de stock
  Future<void> creerNotificationStock(String idproduit, String nomProduit, int quantiteRestante) async {
    try {
      final priorite = quantiteRestante <= 0 ? 'critique' : (quantiteRestante <= 5 ? 'haute' : 'normale');

      final notification = kanjad.Notification(
        idnotification: '',
        titre: 'Alerte Stock',
        message: '$nomProduit: $quantiteRestante unité${quantiteRestante > 1 ? 's' : ''} restante${quantiteRestante > 1 ? 's' : ''}',
        type: 'stock',
        priorite: priorite,
        statut: 'non_lu',
        idproduit: idproduit,
        datecreation: DateTime.now(),
      );

      await _insererNotification(notification);
      developer.log('Notification de stock créée pour $nomProduit (quantité: $quantiteRestante)', name: 'NotificationService');
    } catch (e, stackTrace) {
      developer.log('Erreur création notification stock: $e', name: 'NotificationService', error: e, stackTrace: stackTrace);
      rethrow;
    }
  }

  /// Créer une notification de message direct
  Future<void> creerNotificationMessage(String idutilisateur, String expediteur, String contenu) async {
    try {
      final preview = contenu.length > 50 ? '${contenu.substring(0, 50)}...' : contenu;

      final notification = kanjad.Notification(
        idnotification: '',
        titre: 'Nouveau message',
        message: '$expediteur: $preview',
        type: 'message',
        priorite: 'normale',
        statut: 'non_lu',
        idutilisateur: idutilisateur,
        donneesSupplementaires: {
          'expediteur': expediteur,
          'contenu_complet': contenu,
        },
        datecreation: DateTime.now(),
      );

      await _insererNotification(notification);
      developer.log('Notification de message créée pour $idutilisateur', name: 'NotificationService');
    } catch (e, stackTrace) {
      developer.log('Erreur création notification message: $e', name: 'NotificationService', error: e, stackTrace: stackTrace);
      rethrow;
    }
  }

  /// Créer une notification système personnalisée
  Future<void> creerNotificationSysteme(String titre, String message, String priorite) async {
    try {
      final notification = kanjad.Notification(
        idnotification: '',
        titre: titre,
        message: message,
        type: 'systeme',
        priorite: priorite,
        statut: 'non_lu',
        datecreation: DateTime.now(),
      );

      await _insererNotification(notification);
      developer.log('Notification système créée: $titre', name: 'NotificationService');
    } catch (e, stackTrace) {
      developer.log('Erreur création notification système: $e', name: 'NotificationService', error: e, stackTrace: stackTrace);
      rethrow;
    }
  }

  // ==================== MÉTHODES DE GESTION ====================

  /// Récupérer toutes les notifications avec filtres optionnels
  Future<List<kanjad.Notification>> recupererNotifications({
    String? statut,
    String? type,
    String? priorite,
    int? limite,
  }) async {
    try {
      PostgrestFilterBuilder<PostgrestList> query = supabase.from(tableNotifications).select();

      if (statut != null) {
        query = query.eq('statut', statut);
      }
      if (type != null) {
        query = query.eq('type', type);
      }
      if (priorite != null) {
        query = query.eq('priorite', priorite);
      }

      PostgrestTransformBuilder<PostgrestList> finalQuery = query.order('datecreation', ascending: false);

      if (limite != null) {
        finalQuery = finalQuery.limit(limite);
      }

      final response = await finalQuery;

      final notifications = response
          .map((data) => kanjad.Notification.fromMap(data))
          .toList();

      developer.log('${notifications.length} notifications récupérées', name: 'NotificationService');
      return notifications;
    } catch (e, stackTrace) {
      developer.log('Erreur récupération notifications: $e', name: 'NotificationService', error: e, stackTrace: stackTrace);
      rethrow;
    }
  }

  /// Marquer une notification comme lue
  Future<void> marquerCommeLue(String idnotification) async {
    try {
      await supabase
          .from(tableNotifications)
          .update({
            'statut': 'lu',
            'datelu': DateTime.now().toIso8601String(),
          })
          .eq('idnotification', idnotification);
      developer.log('Notification $idnotification marquée comme lue', name: 'NotificationService');
    } catch (e, stackTrace) {
      developer.log('Erreur marquage comme lu: $e', name: 'NotificationService', error: e, stackTrace: stackTrace);
      rethrow;
    }
  }

  /// Archiver une notification
  Future<void> archiverNotification(String idnotification) async {
    try {
      await supabase
          .from(tableNotifications)
          .update({'statut': 'archive'})
          .eq('idnotification', idnotification);
      developer.log('Notification $idnotification archivée', name: 'NotificationService');
    } catch (e, stackTrace) {
      developer.log('Erreur archivage: $e', name: 'NotificationService', error: e, stackTrace: stackTrace);
      rethrow;
    }
  }

  /// Obtenir un stream de notifications
  Stream<List<kanjad.Notification>> getNotificationsStream({String? statut, String? type}) {
    try {
      final query = supabase.from(tableNotifications).stream(primaryKey: ['idnotification']);

      return query.order('datecreation', ascending: false).map((data) {
        final notifications = data
            .map((item) => kanjad.Notification.fromMap(item))
            .toList();
        developer.log('${notifications.length} notifications reçues du stream', name: 'NotificationService');
        return notifications;
      });
    } catch (e, stackTrace) {
      developer.log('Erreur stream notifications: $e', name: 'NotificationService', error: e, stackTrace: stackTrace);
      rethrow;
    }
  }
}
